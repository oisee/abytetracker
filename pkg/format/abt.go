// Package format handles file I/O for tracker songs
package format

import (
	"bufio"
	"fmt"
	"io"
	"regexp"
	"strconv"
	"strings"

	"github.com/anthropics/abytetracker/pkg/tracker"
)

const FileHeader = "# ABYTETRACKER v1"

// Save writes a song to a writer in .abt format
func Save(w io.Writer, song *tracker.Song) error {
	// Header
	fmt.Fprintln(w, FileHeader)
	fmt.Fprintln(w, "# Generated by abytetracker")
	fmt.Fprintln(w)

	// Song section
	fmt.Fprintln(w, "[song]")
	fmt.Fprintf(w, "title = %s\n", song.Title)
	fmt.Fprintf(w, "author = %s\n", song.Author)
	fmt.Fprintf(w, "tempo = %d\n", song.Tempo)
	fmt.Fprintf(w, "speed = %d\n", song.Speed)
	fmt.Fprintf(w, "rate = %d\n", song.SampleRate)
	fmt.Fprintf(w, "channels = %d\n", song.Channels)
	fmt.Fprintln(w)

	// Instruments section
	fmt.Fprintln(w, "[instruments]")
	fmt.Fprintln(w, "# ID | Name     | Gen | Atk Dec Sus Rel | Orn | Vol")
	for i, inst := range song.Instruments {
		gen := generatorName(inst.Generator)
		fmt.Fprintf(w, "%02d   | %-8s | %s | %3d %3d %3d %3d | %3d | %3d\n",
			i+1, inst.Name, gen,
			inst.Envelope.Attack, inst.Envelope.Decay,
			inst.Envelope.Sustain, inst.Envelope.Release,
			inst.Ornament, inst.Volume)
	}
	fmt.Fprintln(w)

	// Ornaments section
	fmt.Fprintln(w, "[ornaments]")
	fmt.Fprintln(w, "# ID | Name     | Loop | Values")
	for i, orn := range song.Ornaments {
		vals := make([]string, len(orn.Values))
		for j, v := range orn.Values {
			vals[j] = fmt.Sprintf("%d", v)
		}
		fmt.Fprintf(w, "%02d   | %-8s | %4d | %s\n",
			i+1, orn.Name, orn.Loop, strings.Join(vals, ", "))
	}
	fmt.Fprintln(w)

	// Channels section
	fmt.Fprintln(w, "[channels]")
	fmt.Fprintln(w, "# CH | Name   | Gen | Vol | Pan | Echo (src, delay, vol)")
	for i, ch := range song.ChanConfig {
		gen := generatorName(ch.Generator)
		echoSrc := "-"
		if ch.EchoSource >= 0 {
			echoSrc = fmt.Sprintf("%d", ch.EchoSource+1)
		}
		fmt.Fprintf(w, "%d    | %-6s | %s | %3d | %3d | %s, %d, %d\n",
			i+1, ch.Name, gen, ch.Volume, ch.Pan,
			echoSrc, ch.EchoDelay, ch.EchoVolume)
	}
	fmt.Fprintln(w)

	// Order section
	fmt.Fprintln(w, "[order]")
	orderStrs := make([]string, len(song.Order))
	for i, o := range song.Order {
		orderStrs[i] = fmt.Sprintf("%d", o)
	}
	fmt.Fprintln(w, strings.Join(orderStrs, ", "))
	fmt.Fprintln(w)

	// Pattern sections
	for patIdx, pat := range song.Patterns {
		fmt.Fprintf(w, "[pattern %d]\n", patIdx)

		// Header row
		fmt.Fprint(w, "# Row |")
		for ch := 0; ch < pat.Channels; ch++ {
			fmt.Fprintf(w, " Ch%-10d|", ch+1)
		}
		fmt.Fprintln(w)

		// Data rows
		for row := 0; row < pat.Rows; row++ {
			fmt.Fprintf(w, "  %02X  |", row)
			for ch := 0; ch < pat.Channels; ch++ {
				note := pat.Notes[row][ch]
				cell := formatCell(note)
				fmt.Fprintf(w, " %s|", cell)
			}
			fmt.Fprintln(w)
		}
		fmt.Fprintln(w)
	}

	return nil
}

func formatCell(note tracker.Note) string {
	// Format: "C-4 01 40 A04" (note inst vol effect)
	// Empty: "--- -- -- ..."

	noteStr := tracker.NoteToString(note.Pitch)

	instStr := "--"
	if note.Instrument > 0 {
		instStr = fmt.Sprintf("%02X", note.Instrument)
	}

	volStr := "--"
	if note.Volume >= 0 {
		volStr = fmt.Sprintf("%02X", note.Volume)
	}

	fxStr := "..."
	if note.Effect.Type != 0 || note.Effect.Param != 0 {
		fxStr = fmt.Sprintf("%X%02X", note.Effect.Type, note.Effect.Param)
	}

	return fmt.Sprintf("%s %s %s %s", noteStr, instStr, volStr, fxStr)
}

func generatorName(gen tracker.Generator) string {
	switch gen {
	case tracker.GenTriangle:
		return "tri"
	case tracker.GenSawtooth:
		return "saw"
	case tracker.GenSquare:
		return "squ"
	case tracker.GenSawBig:
		return "swb"
	case tracker.GenNoise:
		return "noi"
	case tracker.GenSample:
		return "sam"
	case tracker.GenBytebeat:
		return "bbt"
	default:
		return "tri"
	}
}

func parseGenerator(name string) tracker.Generator {
	switch strings.ToLower(strings.TrimSpace(name)) {
	case "tri", "triangle":
		return tracker.GenTriangle
	case "saw", "sawtooth":
		return tracker.GenSawtooth
	case "squ", "square":
		return tracker.GenSquare
	case "swb", "sawbig":
		return tracker.GenSawBig
	case "noi", "noise":
		return tracker.GenNoise
	case "sam", "sample":
		return tracker.GenSample
	case "bbt", "bytebeat":
		return tracker.GenBytebeat
	default:
		return tracker.GenTriangle
	}
}

// Load reads a song from a reader in .abt format
func Load(r io.Reader) (*tracker.Song, error) {
	song := &tracker.Song{
		Speed:      6,
		Tempo:      125,
		SampleRate: 44100,
		Channels:   4,
	}

	scanner := bufio.NewScanner(r)
	section := ""
	patternIdx := -1

	// Regex for pattern section header
	patternRe := regexp.MustCompile(`^\[pattern\s+(\d+)\]`)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Check for section header
		if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
			if m := patternRe.FindStringSubmatch(line); m != nil {
				section = "pattern"
				patternIdx, _ = strconv.Atoi(m[1])
				// Ensure we have enough patterns
				for len(song.Patterns) <= patternIdx {
					song.Patterns = append(song.Patterns, tracker.NewPattern(64, song.Channels))
				}
			} else {
				section = line[1 : len(line)-1]
				patternIdx = -1
			}
			continue
		}

		// Parse based on section
		switch section {
		case "song":
			parseSongLine(song, line)
		case "instruments":
			if inst := parseInstrumentLine(line); inst != nil {
				song.Instruments = append(song.Instruments, *inst)
			}
		case "ornaments":
			if orn := parseOrnamentLine(line); orn != nil {
				song.Ornaments = append(song.Ornaments, *orn)
			}
		case "channels":
			if ch := parseChannelLine(line); ch != nil {
				song.ChanConfig = append(song.ChanConfig, *ch)
			}
		case "order":
			song.Order = parseOrderLine(line)
		case "pattern":
			if patternIdx >= 0 && patternIdx < len(song.Patterns) {
				parsePatternLine(song.Patterns[patternIdx], line)
			}
		}
	}

	// Ensure channel config matches channel count
	for len(song.ChanConfig) < song.Channels {
		song.ChanConfig = append(song.ChanConfig, tracker.ChannelConfig{
			Name:       fmt.Sprintf("Ch%d", len(song.ChanConfig)+1),
			Generator:  tracker.GenTriangle,
			Volume:     64,
			EchoSource: -1,
		})
	}

	return song, scanner.Err()
}

func parseSongLine(song *tracker.Song, line string) {
	parts := strings.SplitN(line, "=", 2)
	if len(parts) != 2 {
		return
	}
	key := strings.TrimSpace(parts[0])
	val := strings.TrimSpace(parts[1])

	switch key {
	case "title":
		song.Title = val
	case "author":
		song.Author = val
	case "tempo":
		if v, err := strconv.Atoi(val); err == nil {
			song.Tempo = uint8(v)
		}
	case "speed":
		if v, err := strconv.Atoi(val); err == nil {
			song.Speed = uint8(v)
		}
	case "rate", "samplerate":
		if v, err := strconv.Atoi(val); err == nil {
			song.SampleRate = v
		}
	case "channels":
		if v, err := strconv.Atoi(val); err == nil {
			song.Channels = v
		}
	}
}

func parseInstrumentLine(line string) *tracker.Instrument {
	// Format: "01   | Lead     | tri | 0  20  48  30 | 1 | 64"
	parts := strings.Split(line, "|")
	if len(parts) < 6 {
		return nil
	}

	inst := &tracker.Instrument{}
	inst.Name = strings.TrimSpace(parts[1])
	inst.Generator = parseGenerator(parts[2])

	// Parse envelope
	envParts := strings.Fields(parts[3])
	if len(envParts) >= 4 {
		inst.Envelope.Attack, _ = parseUint8(envParts[0])
		inst.Envelope.Decay, _ = parseUint8(envParts[1])
		inst.Envelope.Sustain, _ = parseUint8(envParts[2])
		inst.Envelope.Release, _ = parseUint8(envParts[3])
	}

	inst.Ornament, _ = parseUint8(strings.TrimSpace(parts[4]))
	inst.Volume, _ = parseUint8(strings.TrimSpace(parts[5]))

	return inst
}

func parseOrnamentLine(line string) *tracker.Ornament {
	// Format: "01   | Arp Maj  | 0 | 0, 4, 7"
	parts := strings.Split(line, "|")
	if len(parts) < 4 {
		return nil
	}

	orn := &tracker.Ornament{}
	orn.Name = strings.TrimSpace(parts[1])

	if loop, err := strconv.Atoi(strings.TrimSpace(parts[2])); err == nil {
		orn.Loop = int8(loop)
	}

	// Parse values
	valStrs := strings.Split(parts[3], ",")
	for _, vs := range valStrs {
		if v, err := strconv.Atoi(strings.TrimSpace(vs)); err == nil {
			orn.Values = append(orn.Values, int8(v))
		}
	}

	return orn
}

func parseChannelLine(line string) *tracker.ChannelConfig {
	// Format: "1    | Lead   | tri | 64 | 0 | -, 0, 0"
	parts := strings.Split(line, "|")
	if len(parts) < 6 {
		return nil
	}

	ch := &tracker.ChannelConfig{}
	ch.Name = strings.TrimSpace(parts[1])
	ch.Generator = parseGenerator(parts[2])
	ch.Volume, _ = parseUint8(strings.TrimSpace(parts[3]))

	if pan, err := strconv.Atoi(strings.TrimSpace(parts[4])); err == nil {
		ch.Pan = int8(pan)
	}

	// Parse echo
	echoParts := strings.Split(parts[5], ",")
	ch.EchoSource = -1
	if len(echoParts) >= 1 {
		src := strings.TrimSpace(echoParts[0])
		if src != "-" && src != "" {
			if v, err := strconv.Atoi(src); err == nil {
				ch.EchoSource = int8(v - 1) // 1-based to 0-based
			}
		}
	}
	if len(echoParts) >= 2 {
		ch.EchoDelay, _ = parseUint8(strings.TrimSpace(echoParts[1]))
	}
	if len(echoParts) >= 3 {
		if v, err := strconv.Atoi(strings.TrimSpace(echoParts[2])); err == nil {
			ch.EchoVolume = int8(v)
		}
	}

	return ch
}

func parseOrderLine(line string) []uint8 {
	parts := strings.Split(line, ",")
	var order []uint8
	for _, p := range parts {
		if v, err := strconv.Atoi(strings.TrimSpace(p)); err == nil {
			order = append(order, uint8(v))
		}
	}
	return order
}

func parsePatternLine(pat *tracker.Pattern, line string) {
	// Format: "  00  | C-4 01 -- ...| --- -- -- ...|"
	parts := strings.Split(line, "|")
	if len(parts) < 2 {
		return
	}

	// Parse row number (hex)
	rowStr := strings.TrimSpace(parts[0])
	row, err := strconv.ParseInt(rowStr, 16, 32)
	if err != nil {
		return
	}
	if int(row) >= pat.Rows {
		return
	}

	// Parse each channel
	for ch := 0; ch < pat.Channels && ch+1 < len(parts); ch++ {
		cell := strings.TrimSpace(parts[ch+1])
		if note := parseCell(cell); note != nil {
			pat.Notes[row][ch] = *note
		}
	}
}

func parseCell(cell string) *tracker.Note {
	// Format: "C-4 01 40 A04" or "--- -- -- ..."
	parts := strings.Fields(cell)
	if len(parts) < 4 {
		return nil
	}

	note := &tracker.Note{Pitch: -1, Volume: -1}

	// Note
	if parts[0] != "---" {
		note.Pitch = tracker.StringToNote(parts[0])
	}

	// Instrument
	if parts[1] != "--" {
		if v, err := strconv.ParseInt(parts[1], 16, 32); err == nil {
			note.Instrument = uint8(v)
		}
	}

	// Volume
	if parts[2] != "--" {
		if v, err := strconv.ParseInt(parts[2], 16, 32); err == nil {
			note.Volume = int8(v)
		}
	}

	// Effect
	if parts[3] != "..." && len(parts[3]) >= 3 {
		if typ, err := strconv.ParseInt(parts[3][:1], 16, 32); err == nil {
			note.Effect.Type = uint8(typ)
		}
		if param, err := strconv.ParseInt(parts[3][1:], 16, 32); err == nil {
			note.Effect.Param = uint8(param)
		}
	}

	return note
}

func parseUint8(s string) (uint8, error) {
	v, err := strconv.Atoi(s)
	return uint8(v), err
}
